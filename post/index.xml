<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Random Stuff from GlacJAY</title>
    <link>https://blog.glacjay.info/post/</link>
    <description>Recent content in Posts on Random Stuff from GlacJAY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 23 Apr 2016 10:33:22 +0800</lastBuildDate>
    
	<atom:link href="https://blog.glacjay.info/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Firefox 插件：TooManyTabs</title>
      <link>https://blog.glacjay.info/post/2016-04-23/firefox-%E6%8F%92%E4%BB%B6toomanytabs/</link>
      <pubDate>Sat, 23 Apr 2016 10:33:22 +0800</pubDate>
      
      <guid>https://blog.glacjay.info/post/2016-04-23/firefox-%E6%8F%92%E4%BB%B6toomanytabs/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/toomanytabs-saves-your-memory/&#34;&gt;TooManyTabs&lt;/a&gt; 简直是标(tuo)签(yan)党(zheng)的福音啊！每每在一大堆待读标签里面翻找要看的网页简直要疯掉！包括我和我的内存 ▔fﾟﾟ▔&lt;/p&gt;

&lt;p&gt;但只是简单的插件介绍的话是不足以让我这个万年懒癌晚期开工写博的，主要是这货配合 Firefox 的帐户同步功能的时候有点儿坑：一开始没有给分组重命名的时候，几个电脑的 TooManyTabs 一同步就全乱套了；直到我把各个电脑的分组都分别命名，然后又费了老劲儿地整理一番之后才搞定。&lt;/p&gt;

&lt;p&gt;让我觉得这个插件很神奇的是，它是用 Firefox 的书签功能来保存标签的，但又不是简单地保存网址，因为标签恢复之后其前进后退的历史也都一并恢复了。看来 Firefox 的书签还有很多的隐藏功能有待发掘啊。&lt;/p&gt;

&lt;p&gt;最后的最后，既然是通过书签功能来保存和同步的，那如果 Firefox Android 的书签功能能再给点儿力就好了，让我可以直接把网址保存到指定的分组下面，这样就不用先发送到电脑上再（能用电脑时）TooManyTabs 了（再加上 Firefox Android 的发送标签功能有时还会丢标签）。&lt;/p&gt;

&lt;p&gt;以上&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我的 MBP SSD 优化过程</title>
      <link>https://blog.glacjay.info/post/2015-01-17/%E6%88%91%E7%9A%84-mbp-ssd-%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 17 Jan 2015 16:40:49 +0800</pubDate>
      
      <guid>https://blog.glacjay.info/post/2015-01-17/%E6%88%91%E7%9A%84-mbp-ssd-%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;嗯，这次的标题终于没那么长了 ;-)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;给我的 MBP 换 SSD 已经是很久之前的事了，当时就已经折腾过一次优化了，不过没有相应的记录。最近发现了新装的 Yosemite 的一些老是搞不定而且连原因都不知道的问题（其中一个可以参见&lt;a href=&#34;http://apple.stackexchange.com/questions/163500/when-i-want-to-install-teamviewer-10-why-cant-i-select-my-system-disk-as-the-d&#34; title=&#34;AskDifferent: When I want to install TeamViewer 10, why can&#39;t I select my system disk as the distination?&#34;&gt;我在 AskDifferent 上的提问&lt;/a&gt;），一怒之下重装之，自然对 SSD 的优化也要重新搞一遍。搞的过程中发现有的手段能用，有的却不行，特此记录。&lt;/p&gt;

&lt;p&gt;优化手段的主要来源是&lt;a href=&#34;http://chenyufei.info/blog/2011-09-06/13-%E5%AF%B8-macbook-pro-%E6%8B%86%E5%85%89%E9%A9%B1%E6%9B%B4%E6%8D%A2-ssd/&#34; title=&#34;13 寸 Macbook Pro 拆光驱更换 SSD&#34;&gt;朋友的一篇博文&lt;/a&gt;及其中的链接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：操作有风险，动手须谨慎哟。因为我是不（lan）会（de）做太多解释的，所以你一定要在操作前搞清楚那些个命令的作用哟，特别是像 &lt;code&gt;rm&lt;/code&gt; 啦 &lt;code&gt;mv&lt;/code&gt; 啦之类的危险命令哟，可别说我没提醒你哟 -_-&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Keepalived 实现双机热备并对关键进程进行监控</title>
      <link>https://blog.glacjay.info/post/2014-06-22/keepalived-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E5%B9%B6%E5%AF%B9%E5%85%B3%E9%94%AE%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7/</link>
      <pubDate>Sun, 22 Jun 2014 01:09:12 +0800</pubDate>
      
      <guid>https://blog.glacjay.info/post/2014-06-22/keepalived-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E5%B9%B6%E5%AF%B9%E5%85%B3%E9%94%AE%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7/</guid>
      <description>&lt;p&gt;三连更有木有！（对不起我网文看多了，而且中间其实断过两天的，我不会告诉你其实是我把这事儿给忘了的）&lt;/p&gt;

&lt;p&gt;另，这篇照例是工作需要。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;使用 Keepalived 实现多机热备（无负载均衡）时，除了对网口状态的监控外，一般还要对系统关键进程（如 Web 服务器的话就是 nginx 或者 httpd 之类的）进行监控，这时就要用到 &lt;code&gt;vrrp_script&lt;/code&gt; 配置。网上能找到的 &lt;code&gt;vrrp_script&lt;/code&gt; 示例都使用了 &lt;code&gt;weight&lt;/code&gt; 选项，以实现基于优先级机制的切换，我在使用中遇到了一点儿问题，总结一下。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LoadRunner 中进行 HTTP 测试时使 Keep-Alive 生效的注意事项</title>
      <link>https://blog.glacjay.info/post/2014-06-19/loadrunner-%E4%B8%AD%E8%BF%9B%E8%A1%8C-http-%E6%B5%8B%E8%AF%95%E6%97%B6%E4%BD%BF-keep-alive-%E7%94%9F%E6%95%88%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Thu, 19 Jun 2014 00:23:16 +0800</pubDate>
      
      <guid>https://blog.glacjay.info/post/2014-06-19/loadrunner-%E4%B8%AD%E8%BF%9B%E8%A1%8C-http-%E6%B5%8B%E8%AF%95%E6%97%B6%E4%BD%BF-keep-alive-%E7%94%9F%E6%95%88%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>&lt;p&gt;工作需要，在使用 LoadRunner 进行 HTTP 测试时，为了使每个虚拟用户在不同的循环周期中都能保持长连接，则除了要打开 Keep-Alive 运行时配置（默认打开）之外，还有两个选项需要修改，这两个选项都在运行时配置的「Browser - Browser Simulation」中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Simulate browser cache ：取消勾选。禁用对浏览器缓存机制的模拟，令虚拟用户确实的每次都真正发起与 Web 服务器的对话，而不是只读取一下缓存。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Simulate a new user on each iteration ：取消勾选。不要在每次执行 Action 之前重置虚拟用户的状态，不然会把原来的 TCP 长连接也重置掉，Keep-Alive 就没用了（更准确地说，是在不同循环周期之间就没用了）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>VS2010 环境中调试 IE ActiveX 控制时断点不起作用的问题</title>
      <link>https://blog.glacjay.info/post/2014-06-18/vs2010-%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%B0%83%E8%AF%95-ie-activex-%E6%8E%A7%E5%88%B6%E6%97%B6%E6%96%AD%E7%82%B9%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 18 Jun 2014 22:29:01 +0800</pubDate>
      
      <guid>https://blog.glacjay.info/post/2014-06-18/vs2010-%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%B0%83%E8%AF%95-ie-activex-%E6%8E%A7%E5%88%B6%E6%97%B6%E6%96%AD%E7%82%B9%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;又是惯例的长了好长时间的草，今天先来篇短的。&lt;/p&gt;

&lt;p&gt;工作需要，在使用 VS2010 开发调试 IE ActiveX 插件时，默认条件下下的断点不起作用，这是因为选错了调试器，在工程属性 - Debugging 中的 Debugger to launch 项，选择 Web Browser Debugger ，然后在 HTTP URL 项填本地 HTML 文件的绝对路径，以 file:/// 打头就可以了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenSSL 与 WinSock2 配合使用时遇到的一个坑</title>
      <link>https://blog.glacjay.info/post/2014-03-29/openssl-%E4%B8%8E-winsock2-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</link>
      <pubDate>Sat, 29 Mar 2014 23:06:38 +0800</pubDate>
      
      <guid>https://blog.glacjay.info/post/2014-03-29/openssl-%E4%B8%8E-winsock2-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</guid>
      <description>&lt;p&gt;今天才发现，这里已经两年多没有被照看过了，估计连树都要长出来了吧。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在用 Windows 的 WSAEventSelect 模式进行网络编程时，比较固定的一个模式是这样的：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>修改 OpenVPN 实现加密算法的自动协商</title>
      <link>https://blog.glacjay.info/post/2011-09-17/%E4%BF%AE%E6%94%B9-openvpn-%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/</link>
      <pubDate>Sat, 17 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-09-17/%E4%BF%AE%E6%94%B9-openvpn-%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/</guid>
      <description>&lt;p&gt;由&lt;a href=&#34;https://blog.glacjay.info/post/2011-01-18/openvpn-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/&#34;&gt;另一篇博&lt;/a&gt;中的分析可知，OpenVPN 中有两个加解密通道。一条是标准的 SSL 协议通道，被 OpenVPN 用于协商自己所用的密钥。这个通道的加密算法当然也是通过 SSL 协议来进行协商的，可以通过 &lt;code&gt;--tls-cipher&lt;/code&gt; 选项来进行配置。另一条是 OpenVPN 自己的加解密通道，用于交换实际的数据，也就是虚拟网卡抓到的 IP 报文。这个通道的加密算法则是通过 &lt;code&gt;--cipher&lt;/code&gt; 和 &lt;code&gt;--auth&lt;/code&gt; 两个选项，分别在通调两端指定的。&lt;/p&gt;

&lt;p&gt;对于第二条通道的加密算法，必须要同时在两端分别指定一致的选项，有时候不是很方便（当然，我研究的还是 2.1.1 版本的 OpenVPN ，不知道最新的版本还是不是这样）。比如说，我想通过在服务端修改配置，指定加密算法，然后让连接我的客户端自动用同一个算法。最简单的修改思路，就是借用第一条通道中的算法协商机制，从 SSL 对象中取得协商出来的算法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>编写自己的 Web 版 Google Reader 客户端</title>
      <link>https://blog.glacjay.info/post/2011-08-11/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84-web-%E7%89%88-google-reader-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Thu, 11 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-08-11/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84-web-%E7%89%88-google-reader-%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>&lt;p&gt;最近花在路上的时间明显变多了，手机就成了我打发这些路上时间的利器。小说神马的看太多也会腻，正好 Google Reader 中也积累了大量的未读文章，因此用手机看看订阅文章就成了一个比较好的选择。&lt;/p&gt;

&lt;p&gt;但多次使用下来，却也发现了很多 Google 原版 Web 界面的不方便之处。Google 提供了两个版本的 Reader 界面给手机，一个是苹果风格的 &lt;code&gt;/i/&lt;/code&gt; 界面，设计得很漂亮，功能也很全，用 Nokia 手机也能看，但太费流量（未证实，只是感觉，大概是因为一次加载了很多的文章吧），而且在网络状况不好的时候，体验不太好。另一个是 &lt;code&gt;/m/&lt;/code&gt; 界面，很简洁，选项不多，但也总有些这样那样的细节另我不太满意，下面详述。然后又去找 Nokia 的 S60v3 客户端软件，总之是没一个喜欢啦。作为一个 Geek （至少是自称），在这种情况下，最佳选择自然就是打造一个自己专属的解决方案啦。&lt;/p&gt;

&lt;p&gt;正好蹭着同学的一个 PHP 空间（其实也有 Python 和 Ruby 可选啦，但总觉得会很折腾，还是 PHP 好点，虽然折腾也少不了，见下），于是花了几天时间，连复习 PHP （以前只学过没用过，主要还是看 w3schools 的教程和查 php.net 的函数文档）、研究 OAuth （参见&lt;a href=&#34;http://www.ioncannon.net/programming/1443/google-oauth-for-installed-apps-php-example/&#34;&gt;这篇文章&lt;/a&gt;，不过 Web 应用稍有不同）、研究 Google Reader API （参见&lt;a href=&#34;http://blog.martindoms.com/2009/08/15/using-the-google-reader-api-part-1/&#34;&gt;这系列文章&lt;/a&gt;）、编写代码，终于搞定了一个很阳春的 Google Reader Mobile 版，刚刚满足我的手机阅读需要。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[转载] Compilers: what are you thinking about?</title>
      <link>https://blog.glacjay.info/post/2011-07-26/%E8%BD%AC%E8%BD%BD-compilers-what-are-you-thinking-about/</link>
      <pubDate>Tue, 26 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-07-26/%E8%BD%AC%E8%BD%BD-compilers-what-are-you-thinking-about/</guid>
      <description>&lt;p&gt;最近在翻看以前加星的 Google Reader 文章，把有用的整理出来打标签，然后就看到了这篇。原文作者的博客现在不知道被丢到哪边去了，搜也搜不到，转到这里，权当保存一下吧。&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.onebadseed.com/blog/?p=119&#34;&gt;Compilers: what are you thinking about?&lt;/a&gt;。当然，已经打不开了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;compilers-what-are-you-thinking-about&#34;&gt;Compilers: what are you thinking about?&lt;/h2&gt;

&lt;p&gt;Author: Rotten Cotton&lt;/p&gt;

&lt;p&gt;My recent post &lt;a href=&#34;http://www.onebadseed.com/blog/?p=103&#34;&gt;Compiler bibliography&lt;/a&gt;, a motley list of compiler papers that had been sitting in a box in my attic, generated a surprising amount of traffic: over a thousand unique visitors. But no comments. For those of you interested in compiler design, I ask, what are you trying to understand? What are you trying to do?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之六：匿名函数 lambda</title>
      <link>https://blog.glacjay.info/post/2011-05-21/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%85%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda/</link>
      <pubDate>Sat, 21 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-05-21/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%85%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;既然上次已经提到说，我们其实是在从 Lisp、Scheme 还有类似的其他语言中借鉴各种要实现的功能（我没想过要把这个项目做成原创的⋯⋯或者至少也要等到以后再说吧），那么现在也&lt;strong&gt;是时候&lt;/strong&gt;实现一些更加强大的功能了。&lt;/p&gt;

&lt;h2 id=&#34;那就来做延迟求值以及匿名函数吧&#34;&gt;那就来做延迟求值以及匿名函数吧&lt;/h2&gt;

&lt;p&gt;Lambda ，又名匿名函数，可以像普通的数值或者字符串类型那样被当作函数参数来到处传递，也可以在需要的时候才调用（当然不调也可以）。同时，外层函数（也就是定义匿名函数的函数）作为它们的运行环境，在其中定义的局部变量可以被这些匿名函数所访问。这就形成了[一个闭包](&lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_(computer_science))。我们这次**并不是**要实现完整的闭包功能，只是开头的一小步而已，完整的实现要等到再后面了。&#34;&gt;http://en.wikipedia.org/wiki/Closure_(computer_science))。我们这次**并不是**要实现完整的闭包功能，只是开头的一小步而已，完整的实现要等到再后面了。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之五：整数常量，以及 if 语句</title>
      <link>https://blog.glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 17 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;上次我承诺会发布的更快一些，不过还是失败了⋯⋯作为补偿，这章的内容将会是原计划中的第 5，6，7 章内容的合并，因为这三章确实都很短。闲话少叙：&lt;/p&gt;

&lt;h2 id=&#34;处理数字常量&#34;&gt;处理数字常量&lt;/h2&gt;

&lt;p&gt;到目前为止，我们只处理了一些实现所必须的数字常量，也就是当一个外部函数的返回值是数字的情况，而且没有做任何形式的类型检查。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之四：自定义函数，以及运行时支持</title>
      <link>https://blog.glacjay.info/post/2011-05-09/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%9B%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81/</link>
      <pubDate>Mon, 09 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-05-09/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%9B%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;抱歉，又拖了很长时间。要忙的事情实在很多。正如上一篇文章末尾提到的那样，这次要讲的是自定义函数，以及一个简单的“运行时库”。&lt;/p&gt;

&lt;h2 id=&#34;自定义函数&#34;&gt;自定义函数&lt;/h2&gt;

&lt;p&gt;一门编程语言如果连函数和方法都没有的话，那也就不能算是一门语言了。而且，实践表明，一门面向对象语言中的所有特性都可以通过过程式的语言要素来实现：一个方法也只不过是以一个对象为额外参数的函数而已。因此，增加对函数的支持就是实现一门语言的核心所在。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之三：语句序列，以及子表达式</title>
      <link>https://blog.glacjay.info/post/2011-05-02/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%89%E8%AF%AD%E5%8F%A5%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 02 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-05-02/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%89%E8%AF%AD%E5%8F%A5%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up---step-3.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up&amp;mdash;step-3.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;我本来是想要早点发表的，可是我这周又不行了 &amp;ndash; 虽然整理一篇旧文只需要半个小时。不管怎样，这是第三章，而且我会在末尾大概列一下之后的大纲。由于我会试着把一些小的步骤组合成更有内容的章节（下面就有个这样的例子），因此原来的 30 篇文章已经被我给减到了 20 篇左右（当然，这只是我已经完成了的，后面还有新的呢）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之二：函数调用，以及 Hello World</title>
      <link>https://blog.glacjay.info/post/2011-04-29/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%A5%E5%8F%8A-hello-world/</link>
      <pubDate>Fri, 29 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-04-29/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%A5%E5%8F%8A-hello-world/</guid>
      <description>&lt;p&gt;原文地址：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我会选择 Ruby 来作为我的实现语言并没有什么特别的理由。在现阶段，语言的选择并不重要；不过，我确实很喜欢 Ruby。&lt;/p&gt;

&lt;p&gt;在这之后，我会采取一系列的步骤令所实现的语言向其实现语言靠拢。我的意思是，我想将编译器实现为可以&lt;strong&gt;自举&lt;/strong&gt;的，即它应该能够编译自身。&lt;/p&gt;

&lt;p&gt;而这也就意味着，要么我的编译器需要至少支持 Ruby 语言的一个子集，要么就需要一个中间的翻译步骤，来将编译器中的实现翻译成它自己可以编译的语言。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之一：一个简单的 main 函数模板</title>
      <link>https://blog.glacjay.info/post/2011-04-11/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%80%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-main-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 11 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-04-11/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%80%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-main-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[译者抱怨：翻译好麻烦啊。]&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我已经将这件事情搁置了很长时间了 &amp;ndash; 这个系列中最早的文章甚至可以追溯到 2005 年的早期，而那时我还没有开始写这个博客呢。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之零</title>
      <link>https://blog.glacjay.info/post/2011-04-10/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E9%9B%B6/</link>
      <pubDate>Sun, 10 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-04-10/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E9%9B%B6/</guid>
      <description>&lt;p&gt;这是一个国外的编译器达人写的一系列教程，内容为用 Ruby 语言，以自底向上的方式开发一个 Ruby 语言的编译器。这个教程非常适合于实战派的程序员。该教程的入口见&lt;a href=&#34;http://www.hokstad.com/compiler&#34;&gt;这里&lt;/a&gt;，其代码见&lt;a href=&#34;https://github.com/vidarh/writing-a-compiler-in-ruby&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我会试着翻译一下这个教程。由于这个项目之后又有了很大的进展，而教程本身却又已经很久没有更新了，所以之后我可能也会自己总结一下那些最新的开发工作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>总结一下学到的 LVS 相关知识（ DR 模式）</title>
      <link>https://blog.glacjay.info/post/2011-03-13/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-dr-%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 13 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-03-13/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-dr-%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;不喜欢看长的 Blog 文章，当然更不喜欢写，所以就分开写啦。另，因为 TUN 模式限制更多，实际很可能用不到，所以不一定会写。&lt;/p&gt;

&lt;p&gt;所以这次要讲的是 DR 模式的负载均衡啦。 DR 模式，也就是 Direct Route ，其基本原理就是不对包做任何处理，直接转给所分配的真实服务；回包则由真实服务直接发给客户端而不走负载机。因为不像 NAT 模式那样有相似的架构可以参考，所以这次就上图来说明啦（注，该图偷自&lt;a href=&#34;http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/LVS-HOWTO.LVS-DR.html&#34;&gt;这里&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>总结一下学到的 LVS 相关知识（ NAT 模式）</title>
      <link>https://blog.glacjay.info/post/2011-03-12/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-nat-%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 12 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-03-12/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-nat-%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;LVS，即 Linux Virtual Server 的简称，是 Linux 下用来实现负载均衡的一个项目。它支持三种负载模式，分别为 NAT 、 DR 以及 TUN 。&lt;/p&gt;

&lt;p&gt;注意，我这里讲的都是针对的 2.6 的内核， 2.4 、 2.2 、 2.0 版内核的实现方法和配置方法都各有不一样的地方。还好我不需要维护历史遗留系统（擦汗）。&lt;/p&gt;

&lt;p&gt;首先是最简单的 NAT 模式。这种模式跟普通的 NAT 防火墙的原理差不多，只不过它会根据指定的分配策略，为每一个新的客户端连接选择一个不同的真实服务，而不是像 NAT 防火墙那样只映射到后台的同一个真实服务。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>发布一个寻找局域网内主机的小工具</title>
      <link>https://blog.glacjay.info/post/2011-03-05/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%AF%BB%E6%89%BE%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 05 Mar 2011 22:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-03-05/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%AF%BB%E6%89%BE%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;在工作中，经常需要远程登录到机房中的设备上进行调试与开发，走的是工作局域网。由于这些设备的地址也是动态获取的，因此在遇到一些意外事故，如网线松了、网络不稳定之类的，这些地址可能就变了。每当这时，我们就得跑到机房，给设备连上显示器（我们连 KVM 都没有，命苦啊），查看 IP ，然后再跑回去重新连。太麻烦了。&lt;/p&gt;

&lt;p&gt;我知道有支持动态地址的 DNS 服务，可是我们没权限操作 DNS 服务器，而且设备也都是不固定的，没必要惊动网络管理员（好吧，我甚至都不知道谁是网络管理员，作为三年的“老”员工，我面壁去了。好吧，其实我就是想写写程序练练手），所以我就写了个小程序，用来查找一台特定设备的 IP 地址。&lt;/p&gt;

&lt;p&gt;原理其实很简单啦。客户端（也就是我的笔记本）发个 UDP 广播报文，里面有要找的主机的名字。服务端呢，启动时则指定一个主机名字。当服务端收到一个 UDP 广播报文，并且发现找的就是自己呢，就返回一个 &lt;code&gt;bingo&lt;/code&gt; 报文。这样，客户端就知道这个主机的 IP 地址啦。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux 下有关环境变量与换行符的一个小问题</title>
      <link>https://blog.glacjay.info/post/2011-03-05/linux-%E4%B8%8B%E6%9C%89%E5%85%B3%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 05 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-03-05/linux-%E4%B8%8B%E6%9C%89%E5%85%B3%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;最近在工作中，老是遇到一个莫名其妙的问题。我有一个用来设置一些环境变量的脚本，结果经常发现这个脚本设过的环境变量乱七八糟的，像 PATH 这种，就是之前的值跟后面添加的值重叠在了一起。直到后来才发现，原来是换行符搞的鬼。&lt;/p&gt;

&lt;p&gt;这样说还不太清楚，上代码吧。编辑文本文件 &lt;code&gt;test.sh&lt;/code&gt; 如下，记得以 DOS 换行符的模式来保存：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenVPN 的并发测试方法</title>
      <link>https://blog.glacjay.info/post/2011-01-19/openvpn-%E7%9A%84%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 19 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-01-19/openvpn-%E7%9A%84%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;由于 OpenVPN 本身协议的特殊性，用一般的方法不太好测它的并发。看过 LoadRunner ，但也最多只支持标准的 SSL/TLS 协议（当然，我也没细看这个）。于是动手改了其客户端的实现，最终完成任务。&lt;/p&gt;

&lt;p&gt;其实阻止我们在一台机器上同时跑很多 OpenVPN 客户端的因素就只有虚拟网卡一个。貌似装十个左右的虚拟网卡驱动之后，机器就不行了。于是解决办法也很简单，把虚拟网卡相关的功能跳过就可以了。根据&lt;a href=&#34;https://blog.glacjay.info/post/2011-01-18/openvpn-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/&#34;&gt;上篇&lt;/a&gt;的说明，只要在 &lt;code&gt;incoming_push_message()&lt;/code&gt; 函数中，把对 &lt;code&gt;do_up()&lt;/code&gt; 的调用直接换成 &lt;code&gt;initialization_sequence_completed()&lt;/code&gt; 就 OK 了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenVPN 的初始化过程分析</title>
      <link>https://blog.glacjay.info/post/2011-01-18/openvpn-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 18 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2011-01-18/openvpn-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;题外话：Eclipse CDT 很给力，至少在我用起来，比 gVim + Cscope 或者 SourceInsight 要来得给力，推荐一下。&lt;/p&gt;

&lt;p&gt;更准确的来说，是 OpenVPN 的客户端与服务端之间，从协商密钥、到推送配置，以及最后的网卡与路由配置生效，开始进行 IP 报文的传递，这整个的过程。&lt;/p&gt;

&lt;p&gt;完了。嗯，整个过程就像上面说的，这几个步骤而已。&lt;/p&gt;

&lt;p&gt;不过重点当然还是代码啦。以前一直以为 OpenVPN 的点对点模式下，两端会进行一个决定谁是客户端，谁是服务端的协商过程，一直都想知道是怎么做的。后来才知道，原来通过配置信息，就已经决定好这个了。当然，我下面说的是客户端-服务器模式。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>OpenVPN 的握手协议分析</title>
      <link>https://blog.glacjay.info/post/2010-11-22/openvpn-%E7%9A%84%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 22 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2010-11-22/openvpn-%E7%9A%84%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;又是好久没来这儿了啊。&lt;/p&gt;

&lt;p&gt;最近因为工作需要（其实也没需要那么多），一直在断断续续地看 OpenVPN 的代码，终于大概搞清楚了它的握手是怎么个流程了。简单来说的话其实非常的简单，首先在 &lt;code&gt;reliable&lt;/code&gt; 模块中实现了一个可靠的 UDP 报文协议，就是加上超时重传和确认报文的功能；然后用该协议交换一个 Hard Reset 命令，开始握手；最后建立 SSL 对象，并且通过内存 &lt;code&gt;BIO&lt;/code&gt; 在可靠 UDP 协议的基础上转发 OpenSSL 的握手协议报文，通过这个 SSL 连接交换 OpenVPN 自己的密钥。接下来就是用这些密钥，该干嘛干嘛了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 Python 操作虚拟网卡</title>
      <link>https://blog.glacjay.info/post/2010-09-18/%E7%94%A8-python-%E6%93%8D%E4%BD%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/</link>
      <pubDate>Sat, 18 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2010-09-18/%E7%94%A8-python-%E6%93%8D%E4%BD%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/</guid>
      <description>&lt;p&gt;在我的 &lt;a href=&#34;https://blog.glacjay.info/post/2009-12-19/%E5%88%A9%E7%94%A8-xmpp-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0-vpn/&#34;&gt;XTunnel&lt;/a&gt; 项目中，已经用 Python 作过这种相对底层的工作了（这说明 Python 果然还是非常强大的，上下层通吃啊），不过那边目前还是只实现了 Linux 的版本。后来我又陆陆续续地把 Windows 以及 Mac 下的操作方法给搞通了，今天就来总结一下。&lt;/p&gt;

&lt;p&gt;在 Linux 内核中，特别是在现在的发行版中，应该都已经有了 &lt;code&gt;TUN/TAP&lt;/code&gt; 虚拟网卡的驱动程序，看一下有没有 &lt;code&gt;/dev/net/tun&lt;/code&gt; 这个文件就可以知道了。如果没有，就执行一下 &lt;code&gt;sudo modprobe tun&lt;/code&gt; 这个命令吧。如果还是没有，那就 Google 之吧。下面上代码：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>通过 ODBC 接口访问 Oracle 数据库 -- Linux 篇</title>
      <link>https://blog.glacjay.info/post/2010-03-03/%E9%80%9A%E8%BF%87-odbc-%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE-oracle-%E6%95%B0%E6%8D%AE%E5%BA%93----linux-%E7%AF%87/</link>
      <pubDate>Wed, 03 Mar 2010 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2010-03-03/%E9%80%9A%E8%BF%87-odbc-%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE-oracle-%E6%95%B0%E6%8D%AE%E5%BA%93----linux-%E7%AF%87/</guid>
      <description>&lt;p&gt;首先，你要安装好 UnixODBC 软件包，这个就不多说了。&lt;/p&gt;

&lt;p&gt;然后，安装 Oracle 官方客户端，因为我的使用环境为 Fedora 12 ，所以我下载安装的是 &lt;code&gt;oracle-xe-client-10.2.0.1-1.0.i386.rpm&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;装好之后，要设置一些环境变量，我是用的一个 Shell 脚本来完成这项工作的，你可以把它放在 &lt;code&gt;/etc/profile.d/&lt;/code&gt; 目录下并加上可执行权限来让其在系统启动时自动执行，也可以直接运行这个脚本来使其立即生效。脚本如下：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Oracle 建库 SQL 脚本</title>
      <link>https://blog.glacjay.info/post/2010-03-02/oracle-%E5%BB%BA%E5%BA%93-sql-%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Tue, 02 Mar 2010 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2010-03-02/oracle-%E5%BB%BA%E5%BA%93-sql-%E8%84%9A%E6%9C%AC/</guid>
      <description>-- 首先是删除该数据库中该用户名下的所有表、序列与触发器， -- 其中触发器是通过表格级联删除的。 declare cursor usertables is select * from user_tables where table_name not like &#39;BIN$%&#39;; cursor usersequences is select * from user_sequences; begin for next_row in usertables loop execute immediate &#39;drop table &#39; || next_row.table_name || &#39; cascade constraints&#39;; end loop; for next_row in usersequences loop execute immediate &#39;drop sequence &#39; || next_row.sequence_name; end loop; end; / -- 然后，就是一砣……的建表语句啦， -- 比方说下面就是两个含外键的表。 create table &amp;quot;A&amp;quot; ( &amp;quot;ID&amp;quot; integer primary key, &amp;quot;NAME&amp;quot; nvarchar2(64) not null -- nvarchar2类型支持UTF8 ); -- Oracle中的表名与字段名最好写成这样引号加全大写的形式。 create table &amp;quot;B&amp;quot; ( &amp;quot;ID&amp;quot; integer primary key, &amp;quot;A&amp;quot; integer not null references &amp;quot;B&amp;quot; on delete cascade, &amp;quot;VALUE&amp;quot; nvarchar2(64) not null ); -- 接下来是第三部分，为所有的表创建对应的序列和触发器，以实现自增主键。 declare cursor usertables is select cols.</description>
    </item>
    
    <item>
      <title>利用 XMPP 协议实现 VPN</title>
      <link>https://blog.glacjay.info/post/2009-12-19/%E5%88%A9%E7%94%A8-xmpp-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0-vpn/</link>
      <pubDate>Sat, 19 Dec 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-12-19/%E5%88%A9%E7%94%A8-xmpp-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0-vpn/</guid>
      <description>&lt;p&gt;这主意是我&lt;a href=&#34;http://chenyufei.info&#34;&gt;一同学&lt;/a&gt;想到的（至少是他告诉我的），基于一种实际的需要。假设你有两台内网机，都没有公网地址，你想从一台机器访问另一台机器的服务，这时要怎么办呢？当然很可能是我无知了，就我所知，网上倒是有一些提供这类服务的网站，但都是基于 Windows 的远程桌面的，至于 Linux ，我没找过。&lt;/p&gt;

&lt;p&gt;于是那家伙联想到了 IM Bot 这种东西。现在网上有各种各样的 IM Bot ，可以通过与之聊天执行各种各样的自动化任务，那为什么不能让它把发过去的命令交给另一台机器的 Shell 执行，并把结果返回呢？这不就实现了一个简单的 Telnet 了吗？这就是最初的想法了（我没去找现成实现，因为我也该练练手了）。而我刚好才折腾过 OpenVPN ，于是就有了标题所说的这个最终想法。这样的话，就能一下子从只支持一种应用协议到支持几乎所有的应用协议了，而且实现的工作量也同时减到了最低。真是好主意啊，自我夸奖一下 :-)&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>让 Vim 在保存时自动调用外部命令进行格式化</title>
      <link>https://blog.glacjay.info/post/2009-12-13/%E8%AE%A9-vim-%E5%9C%A8%E4%BF%9D%E5%AD%98%E6%97%B6%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Sun, 13 Dec 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-12-13/%E8%AE%A9-vim-%E5%9C%A8%E4%BF%9D%E5%AD%98%E6%97%B6%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>&lt;p&gt;肯定有许多人遇到过这个问题，也肯定有许多现成的解决方案被发现，可是我没找到（或者说没耐心找）。无所谓，自己找到的话，得到的就不仅仅是最终结果了。&lt;/p&gt;

&lt;p&gt;闲话少说。其实以前也干过类似的事情，就是在保存的时候自动去掉所有的行末空白；不过这个操作使用 Vim 本身的功能就能实现，不需要借助于外部程序，所以只要简单地设一个 &lt;code&gt;BufWrite&lt;/code&gt; 时的自动命令就行了。但当需要借助外部程序的时候，在 &lt;code&gt;BufWrite&lt;/code&gt; 或者 &lt;code&gt;BufWritePre&lt;/code&gt; 或者 &lt;code&gt;FileWritePre&lt;/code&gt; 时执行的自动命令就不行了，老是提示说什么文件本身已更改，是否确定写入。我在这上面反覆试了好多次，才发现是自己没有搞清楚底下到底发生了什么。要让外部程序对文件内容进行格式化（或者其他什么操作。我想调的是 gofmt，顺带一提），首先当然得要那个外部程序能看到你做过的，还没有保存的更改，所以说应该是先写入再操作的，即在 &lt;code&gt;BufWritePost&lt;/code&gt; 的时候执行自动命令。而我一开始就把基本步骤给搞反了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Visual Studio 2008 为 Windows CE 开发编译 OpenSSL</title>
      <link>https://blog.glacjay.info/post/2009-12-05/%E4%BD%BF%E7%94%A8-visual-studio-2008-%E4%B8%BA-windows-ce-%E5%BC%80%E5%8F%91%E7%BC%96%E8%AF%91-openssl/</link>
      <pubDate>Sat, 05 Dec 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-12-05/%E4%BD%BF%E7%94%A8-visual-studio-2008-%E4%B8%BA-windows-ce-%E5%BC%80%E5%8F%91%E7%BC%96%E8%AF%91-openssl/</guid>
      <description>&lt;p&gt;我的编译环境是 Visual Studio Team System 2008 版本 9.0.21022.8 RTM ， Windows Mobile 5.0 SDK R2 （ VS2008 自带的版本）。当然， Perl 也是需要的，我装的是 ActivePerl 。我要编译的 OpenSSL 版本是 0.9.8e 。&lt;/p&gt;

&lt;h2 id=&#34;vs2008-的安装&#34;&gt;VS2008 的安装&lt;/h2&gt;

&lt;p&gt;那个 Web Developer Tools （好像叫这个）的安装会失败，又不能不装，根据网上的说明，要把它的目录单独从光盘上解压出来安装，且安装的时候要挂 Office 的安装光盘（我的 Office 版本是 2007 ）。这个装好了之后，再从光盘上安装 VS2008 就没有问题了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Haskell 中实现 Generic zip 函数</title>
      <link>https://blog.glacjay.info/post/2009-07-14/%E5%9C%A8-haskell-%E4%B8%AD%E5%AE%9E%E7%8E%B0-generic-zip-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 14 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-07-14/%E5%9C%A8-haskell-%E4%B8%AD%E5%AE%9E%E7%8E%B0-generic-zip-%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;其实嗫，这个问题已经有标准和其他的解决方案了。标准解决方案参见 &lt;code&gt;Control.Applicative&lt;/code&gt; 中的 &lt;code&gt;ZipList&lt;/code&gt; ，不过这东东用起来蛮麻烦的说；其他解决方案见 bff 库的 &lt;code&gt;Data.Zippable&lt;/code&gt; 模块，嗯，我还没搞明白这玩意怎么用，不过总感觉杀鸡用牛刀了有点（Template Haskell ，以及其他依赖）。&lt;/p&gt;

&lt;p&gt;所以，如果你只是跟我一样，看 &lt;code&gt;Data.List&lt;/code&gt; 中的那一砣 &lt;code&gt;zipn&lt;/code&gt; 不顺眼的话（其实也只是看着不顺哈，用着还是蛮顺的，反正实现不用我写），一个更简单的方案在此：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Haskell 中的可变长参数列表</title>
      <link>https://blog.glacjay.info/post/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</link>
      <pubDate>Wed, 06 May 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;p&gt;说实话，我之前有就这个题目很有激情地写了很长很罗嗦的一篇草稿的，哦，确切来说是大半篇，直到被打断，激情不再，这篇草稿也就此躺了两个多月。好吧，其实是我还不是八卦那块料，就不卖弄了，直接总结。&lt;/p&gt;

&lt;p&gt;要在 Haskell 中实现可变长参数列表，就是利用其 Typeclass 系统，对函数进行最终结果类型和中间函数类型之间的重载，然后利用 Haskell 的类型推导机制为我们自动调用合适的重载版本。嗯，就这么简单。下面是一个最简单的例子：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>有关 C/C&#43;&#43; 中的 do { ... } while (0) 惯用法</title>
      <link>https://blog.glacjay.info/post/2009-04-08/%E6%9C%89%E5%85%B3-c/c---%E4%B8%AD%E7%9A%84-do--...--while-0-%E6%83%AF%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 08 Apr 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-04-08/%E6%9C%89%E5%85%B3-c/c---%E4%B8%AD%E7%9A%84-do--...--while-0-%E6%83%AF%E7%94%A8%E6%B3%95/</guid>
      <description>&lt;p&gt;C/C++ 中的宏是个让人又爱又恨的家伙（感觉这句话好俗啊），在带给我们很强大的 Power 的同时，却也需要我们绝对的细心，而这也是在宏定义中诸多惯用法的由来。&lt;/p&gt;

&lt;p&gt;当我们要把一组语句定义成一个宏，并希望像用一条语句那样来使用它的时候，我们就可以这样做：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MiniJava 语法中的 non-LALR(1) 的部分及用 Bison 的解决方案</title>
      <link>https://blog.glacjay.info/post/2009-03-22/minijava-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-non-lalr1-%E7%9A%84%E9%83%A8%E5%88%86%E5%8F%8A%E7%94%A8-bison-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 22 Mar 2009 22:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-03-22/minijava-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-non-lalr1-%E7%9A%84%E9%83%A8%E5%88%86%E5%8F%8A%E7%94%A8-bison-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;p&gt;我正在看&lt;a href=&#34;http://www.cs.princeton.edu/~appel/modern/java/&#34;&gt;虎书&lt;/a&gt;，在这本书中所给出的那个 &lt;a href=&#34;http://www.cambridge.org/us/features/052182060X/&#34;&gt;MiniJava&lt;/a&gt; 语言的语法并不是 LALR(1) 语法，因此在某些情况下，所生成的语法分析器会对正确的输入给出语法解析错误。不过 Bison 提供了一个简单而又强大的&lt;a href=&#34;http://www.gnu.org/software/bison/manual/html_mono/bison.html#Generalized-LR-Parsing&#34;&gt;解决方案&lt;/a&gt;，可以轻易的解决掉这个问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 中的纯虚析构函数与抽象类</title>
      <link>https://blog.glacjay.info/post/2009-03-22/c---%E4%B8%AD%E7%9A%84%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link>
      <pubDate>Sun, 22 Mar 2009 20:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-03-22/c---%E4%B8%AD%E7%9A%84%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid>
      <description>&lt;p&gt;我以前只知道，在 C++ 中，如果要表示一个类是抽象基类，只要为它定义一个纯虚析构函数就可以了，没想到今天用到的时候才发现，连接的时候通不过，说没有找到那个函数的定义。到网上一搜才知道，原来纯虚函数也是可以有定义的啊。在实现文件中加上它的空定义之后，一切就 OK 了。&lt;/p&gt;

&lt;p&gt;不过，因为我那个基类里面已经有了一个纯虚函数，所以貌似没必要把析构函数也定义成纯虚的。&lt;/p&gt;

&lt;p&gt;PS. 在 C++ 里面要实现 AST 还真是一件麻烦的体力劳动，要写那么多类，每个类还得写那么一砣的样板代码。幸好不是那种长期运行的服务器程序，不需要太考虑 memory leak 的问题，就不用写析构函数和 &lt;code&gt;delete&lt;/code&gt; 了（实际上是懒得写），不然样板代码还要更大砣。不知道有什么更好的方法没。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>对 Bison 手册中的 C&#43;&#43; 的例子的总结</title>
      <link>https://blog.glacjay.info/post/2009-03-19/%E5%AF%B9-bison-%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84-c---%E7%9A%84%E4%BE%8B%E5%AD%90%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 19 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-03-19/%E5%AF%B9-bison-%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84-c---%E7%9A%84%E4%BE%8B%E5%AD%90%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;注意，我用的软件版本为：Bison - 2.4.1，Flex - 2.5.35 。至于老的版本会怎样我就不深究了。工具不是重点。&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;%skeleton &amp;quot;lalr1.cc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%language &amp;quot;c++&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来代替了，其中参数 &amp;ldquo;c++&amp;rdquo; 不区分大小写。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bison 中的 Prologue 的格式变迁</title>
      <link>https://blog.glacjay.info/post/2009-03-18/bison-%E4%B8%AD%E7%9A%84-prologue-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%98%E8%BF%81/</link>
      <pubDate>Wed, 18 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-03-18/bison-%E4%B8%AD%E7%9A%84-prologue-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%98%E8%BF%81/</guid>
      <description>&lt;p&gt;今天在用 Bison 手册中的 C++ 例子作为一个编译器前端实现的起点时发现，这个官方示例居然编译通不过，具体错误为在 Bison 生成的头文件中，没有 Driver 类的声明。按照 POSIX Yacc 标准，位于 &lt;code&gt;%union&lt;/code&gt; 块之前的 Prologue 区中的代码，应该会被拷到头文件中的啊，于是 google 半天，在某个地方的 Bison ChangeLog 中找到了线索。&lt;/p&gt;

&lt;p&gt;原来，POSIX Yacc 确实应该符合上述行为，可是 Bison 这家伙为了统一性，从 2.3a 版开始，就把所有 Prologue 中的代码，不管是 %union 前的还是之后的，统统只拷到实现文件中而不管头文件了。而为了对应不同的需求，又新增了一套 Prologue 语法，就是 &lt;code&gt;%before-header&lt;/code&gt; 等四个新的 directive。好吧，这样也不错，以显式的统一格式的声明代替了可能会让人抓狂的隐规则。遂试之，结果告诉我说语法错误。接着往上看 ChangeLog 才发现，到了 2.3b 就又改了，把 &lt;code&gt;%before-header&lt;/code&gt; 改成了 &lt;code&gt;%code&lt;/code&gt; 之类的。这回终于没问题了。&lt;/p&gt;

&lt;p&gt;我说，这也太不厚道了吧，这种兼容性改动，我在它的文档里面扒了半天都没看到半个字，而且还是出现在流行度这么高的软件中。于是深刻体会到「错文档不如无文档」的道理啊。由此看来，要做好软件还是需要有相当的责任感的啊。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>