<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=generator content="Hugo 0.76.0"><title>[翻译] 用 Ruby 写编译器之六：匿名函数 lambda &#183; Random Stuff from GlacJAY</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=/css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=/css/side-menu.css><!--<![endif]--><link rel=stylesheet href=/css/blackburn.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.9.0/css/all.css><link href="https://fonts.googleapis.com/css?family=Raleway"rel=stylesheet type=text/css><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="shortcut icon"href=https://blog.glacjay.info/img/favicon.ico type=image/x-icon><link rel=stylesheet href=https://blog.glacjay.info/glacjay.css></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><a class="pure-menu-heading brand"href=/>GlacJAY</a><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=/post/><i class="fa fa-list fa-fw"></i>归档</a></li><li class=pure-menu-item><a class=pure-menu-link href=/tags/><i class="fa fa-tags fa-fw"></i>标签</a></li></ul></div><div class="pure-menu social"><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=https://twitter.com/glacjay rel=me target=_blank><i class="fab fa-twitter-square fa-fw"></i>Twitter</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://github.com/glacjay rel=me target=_blank><i class="fab fa-github-square fa-fw"></i>GitHub</a></li></ul></div><div><div class=small-print><small></small></div><div class=small-print><small>Built with&nbsp;<a href=https://gohugo.io/ target=_blank>Hugo</a></small>
<small>Theme&nbsp;<a href=https://github.com/yoshiharuyamashita/blackburn target=_blank>Blackburn</a></small></div></div></div><div id=main><div class=header><h1>[翻译] 用 Ruby 写编译器之六：匿名函数 lambda</h1><h2></h2></div><div class=content><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i><time>2011-05-21 00:00</time></div><div><i class="fa fa-tags fa-fw"></i><a class=post-taxonomy-tag href=https://blog.glacjay.info/tags/compiler>compiler</a>&nbsp;/
<a class=post-taxonomy-tag href=https://blog.glacjay.info/tags/linux>linux</a>&nbsp;/
<a class=post-taxonomy-tag href=https://blog.glacjay.info/tags/ruby>ruby</a></div></div><p>原文链接：<a href=http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html>http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html</a></p><hr><p>既然上次已经提到说，我们其实是在从 Lisp、Scheme 还有类似的其他语言中借鉴各种要实现的功能（我没想过要把这个项目做成原创的⋯⋯或者至少也要等到以后再说吧），那么现在也<strong>是时候</strong>实现一些更加强大的功能了。</p><h2 id=那就来做延迟求值以及匿名函数吧>那就来做延迟求值以及匿名函数吧</h2><p>Lambda ，又名匿名函数，可以像普通的数值或者字符串类型那样被当作函数参数来到处传递，也可以在需要的时候才调用（当然不调也可以）。同时，外层函数（也就是定义匿名函数的函数）作为它们的运行环境，在其中定义的局部变量可以被这些匿名函数所访问。这就形成了[一个闭包](<a href=http://en.wikipedia.org/wiki/Closure_(computer_science>http://en.wikipedia.org/wiki/Closure_(computer_science</a>))。我们这次<strong>并不是</strong>要实现完整的闭包功能，只是开头的一小步而已，完整的实现要等到再后面了。</p><p>其实说到底，正如编程语言中的其他很多功能一样，闭包也只是又一种语法糖而已。比如说，你可以认为这样其实是定义了一个类，这个类中有唯一一个需要被调用的方法，还有一些作为运行环境的成员变量（或者你也可以反过来<a href=http://strlen.com/bla/index.html>用闭包来实现面向对象系统</a> &ndash; 这是由 <a href=http://strlen.com/>Wouter van Oortmerssen</a> 所提出来的观点。自从我发现 <a href=http://strlen.com/e/index.html>Amiga E</a> 这个项目之后，作为作者的他就成了我的偶像。如果你是一个编程语言方面的极客的话，那你就一定要去看看 Wouter 所做过的东西） &ndash; 有很多功能其实都是相互正交的。</p><p>（ blah blah blah ⋯⋯这个人在说自己很啰嗦之类的，就不翻了）</p><p>那么，为了避免定义很多具名小函数的麻烦，同时降低函数重名的概率， lambda 允许你在任何需要它们的地方进行定义，并且返回一个表示所定义函数的值。</p><p>我们现在所要增加的是像下面这样的东西：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cl data-lang=cl>(<span style=color:#366>lambda</span> (<span style=color:#033>args</span>) <span style=color:#033>body</span>)
(<span style=color:#033>call</span> <span style=color:#033>f</span> (<span style=color:#033>args</span>))
</code></pre></td></tr></table></div></div><p>第一个表达式会返回所定义的函数（目前来说，其实就是这个函数的起始地址），而不是去执行这个函数。而 <code>call</code> ，当然就是以指定的参数列表，来调用传给它的那个函数地址。</p><p>那么，这跟“真正”的闭包又有什么区别呢？</p><p>最重要的一点就是，当你在 lambda 中引用了外层作用域中的某个变量后，那么，当以后对同一个 lambda 进行调用时，这个变量还是可以访问的。这样的变量与 lambda 绑定在了一起。当然，只是得到一个函数的地址的话，肯定是实现不了这个功能的。让我们来看一种实现闭包的技术吧，这样你就能够了解大概所要做的工作了（工作量不大，但也不小）：</p><ul><li>我们可以创建一个“环境”，一个存放那些被引用到的外部变量的地方，以使得当外层函数返回之后，它们也可以继续存在。这个环境必须是在堆中，而且每次对外层函数的调用，都需要创建一个新的环境。</li><li>我们必须返回一个可以用来访问这个环境的东西。你可以返回一个对象，其中的成员变量就是被 lambda 引用到的那些变量。或者你也可以用一个 thunk （中文叫啥呢？），也就是自动生成出来的一个包含有指向这个对象指针的小函数，它会在调用我们的 lambda 之前将这个对象加载到预先指定的地方。或者你也可以用什么其他的办法。</li><li>你必须决定有哪些变量需要放入这个环境中。可以是外层函数中的所有局部变量，当然也可以只是那些被引用到的变量。后一种作法可以节省一定的内存空间，但是需要作更多的工作。</li></ul><p>好吧，还是让我们先来把匿名函数本身给弄出来吧。就像以前一样，我会一步一步地说明所要做的修改，但我同时也会对之前的代码做一些整理。这些整理的部分我就不一一说明了。</p><p>首先是对 lambda 表达式本身进行处理的方法：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>  <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>compile_lambda</span> args, body
    <span style=color:#366>name</span> <span style=color:#555>=</span> <span style=color:#c30>&#34;lambda__</span><span style=color:#a00>#{</span>@seq<span style=color:#a00>}</span><span style=color:#c30>&#34;</span>
    @seq <span style=color:#555>+=</span> <span style=color:#f60>1</span>
    compile_defun(<span style=color:#366>name</span>, args,body)
    <span style=color:#366>puts</span> <span style=color:#c30>&#34;</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#c30>movl</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#c30>$</span><span style=color:#a00>#{</span><span style=color:#366>name</span><span style=color:#a00>}</span><span style=color:#c30>,%eax&#34;</span>
    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>[</span><span style=color:#fc3>:subexpr</span><span style=color:#555>]</span>
  <span style=color:#069;font-weight:700>end</span>
</code></pre></td></tr></table></div></div><p>这个实现应该是很容易理解的吧。我们在这里做的，就是给要定义的匿名函数，生成一个形如 <code>lambda__[number]</code> 的函数名，然后就把它当作一个普通函数来处理了。虽然你也可以就把它生成到外层函数的函数体中，但我发现那样做的话，就会显得很乱的样子，所以我现在还是就把它作为单独的函数来处理了。然后我们调用 <code>#compile_defun</code> 方法来处理这个函数，这样的话，这个函数其实也就只有对用户来说，才是真正匿名的了。然后我们把这个函数的地址保存在寄存器 <code>%eax</code> 中，这里同时也是我们存放子表达式结果的地方。当然，这是一种很懒的作法啦，我们迟早需要为复杂的表达式，实现更加强大的处理机制的。但寄存器分配果然还是很麻烦的一件事情，所以现在就先这样吧（将所有的中间结果压入栈中也是一种可行的作法啦，不过那样比较慢）。</p><p>最后，我们返回一个 <code>[:subexpr]</code> ，来告拆调用者到哪边可以得到这个 lambda 的值。</p><p>之后是一些重构。你也许已经注意到了， <code>#compile_exp</code> 中的代码有点乱，因为要处理不同类型的参数。让我们把这部分代码给提取出来：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>  <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>compile_eval_arg</span> arg
    atype, aparam <span style=color:#555>=</span> get_arg(arg)
    <span style=color:#069;font-weight:700>return</span> <span style=color:#c30>&#34;$.LC</span><span style=color:#a00>#{</span>aparam<span style=color:#a00>}</span><span style=color:#c30>&#34;</span> <span style=color:#069;font-weight:700>if</span> atype <span style=color:#555>==</span> <span style=color:#fc3>:strconst</span>
    <span style=color:#069;font-weight:700>return</span> <span style=color:#c30>&#34;$</span><span style=color:#a00>#{</span>aparam<span style=color:#a00>}</span><span style=color:#c30>&#34;</span> <span style=color:#069;font-weight:700>if</span> atype <span style=color:#555>==</span> <span style=color:#fc3>:int</span>
    <span style=color:#069;font-weight:700>return</span> aparam<span style=color:#555>.</span>to_s <span style=color:#069;font-weight:700>if</span> atype <span style=color:#555>==</span> <span style=color:#fc3>:atom</span>
    <span style=color:#069;font-weight:700>return</span> <span style=color:#c30>&#34;%eax&#34;</span>
  <span style=color:#069;font-weight:700>end</span>
</code></pre></td></tr></table></div></div><p>要注意的是，这里又出现了一个新的 <code>:atom</code> 类型。借助于此，我们就可以把一个 C 函数的地址传给 <code>:call</code> 指令了。反正实现起来也很简单。当然，我们还要在 <code>#get_arg</code> 方法中加上如下代码，以使其生效：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>[</span><span style=color:#fc3>:atom</span>, a<span style=color:#555>]</span> <span style=color:#069;font-weight:700>if</span> (a<span style=color:#555>.</span>is_a?(<span style=color:#360>Symbol</span>))
</code></pre></td></tr></table></div></div><p>然后，作为重构的一部分，对 <code>:call</code> 的处理被分离了出来，成为一个单独的方法：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>  <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>compile_call</span> func, args
    stack_adjustment <span style=color:#555>=</span> <span style=color:#360>PTR_SIZE</span> <span style=color:#555>+</span> (((args<span style=color:#555>.</span>length<span style=color:#555>+</span><span style=color:#f60>0</span><span style=color:#555>.</span><span style=color:#f60>5</span>)<span style=color:#555>*</span><span style=color:#360>PTR_SIZE</span><span style=color:#555>/</span>(<span style=color:#f60>4</span><span style=color:#555>.</span><span style=color:#f60>0</span><span style=color:#555>*</span><span style=color:#360>PTR_SIZE</span>))<span style=color:#555>.</span>round) <span style=color:#555>*</span> (<span style=color:#f60>4</span><span style=color:#555>*</span><span style=color:#360>PTR_SIZE</span>)
    <span style=color:#366>puts</span> <span style=color:#c30>&#34;</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#c30>subl</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#c30>$</span><span style=color:#a00>#{</span>stack_adjustment<span style=color:#a00>}</span><span style=color:#c30>, %esp&#34;</span>
    args<span style=color:#555>.</span>each_with_index <span style=color:#069;font-weight:700>do</span> <span style=color:#555>|</span>a,i<span style=color:#555>|</span>
      param <span style=color:#555>=</span> compile_eval_arg(a)
      <span style=color:#366>puts</span> <span style=color:#c30>&#34;</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#c30>movl</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#a00>#{</span>param<span style=color:#a00>}</span><span style=color:#c30>, </span><span style=color:#a00>#{</span>i<span style=color:#555>&gt;</span><span style=color:#f60>0</span> <span style=color:#555>?</span> i<span style=color:#555>*</span><span style=color:#f60>4</span> : <span style=color:#c30>&#34;&#34;</span><span style=color:#a00>}</span><span style=color:#c30>(%esp)&#34;</span>
    <span style=color:#069;font-weight:700>end</span>

    res <span style=color:#555>=</span> compile_eval_arg(func)
    res <span style=color:#555>=</span> <span style=color:#c30>&#34;*%eax&#34;</span> <span style=color:#069;font-weight:700>if</span> res <span style=color:#555>==</span> <span style=color:#c30>&#34;%eax&#34;</span> <span style=color:#09f;font-style:italic># Ugly. Would be nicer if retain some knowledge of what res contains.</span>
    <span style=color:#366>puts</span> <span style=color:#c30>&#34;</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#c30>call</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#a00>#{</span>res<span style=color:#a00>}</span><span style=color:#c30>&#34;</span>
    <span style=color:#366>puts</span> <span style=color:#c30>&#34;</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#c30>addl</span><span style=color:#c30;font-weight:700>\t</span><span style=color:#a00>#{</span>stack_adjustment<span style=color:#a00>}</span><span style=color:#c30>, %esp&#34;</span>
    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>[</span><span style=color:#fc3>:subexpr</span><span style=color:#555>]</span>
  <span style=color:#069;font-weight:700>end</span>
</code></pre></td></tr></table></div></div><p>看起来很熟悉对不对？因为它就是原来的 <code>#compile_exp</code> 方法，只不过是用 <code>#compile_eval_arg</code> 替换掉了其中的一些代码。另外有改动的地方，就是同时也用 <code>#compile_eval_arg</code> 方法来得到要调用的函数，并对可能得到的 <code>%eax</code> 做了些手脚，在前面加了个星号。</p><p>如果你知道这是怎么回事的话，你也许已经开始寻思其他的点子了，而不管那是真正的好事，还只是开枪打自己的脚。上面的代码其实就相当于，你把任意一个表达式的值当作指向一段代码的指针，然后也不做任何的检查，就直接跳过去执行它。如果是往一个随机的地址进行跳转的话，你最有可能得到的就是一个段错误了。当然，你也可以很容易地通过这项技术，来实现面向对象系统中的虚函数跳转表，或者其他的什么东西。因此，安全性将会是以后必须要考虑的东西。还有就是，要实现对一个地址（而不是函数名）的间接调用，你必须要在这个地址前面加上星号。</p><p>那么，现在的 <code>#compile_exp</code> 方法变成什么样子了呢？简单来说就是，变得整齐多了：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>  <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>compile_do</span>(<span style=color:#555>*</span>exp)
    exp<span style=color:#555>.</span>each { <span style=color:#555>|</span>e<span style=color:#555>|</span> compile_exp(e) }
    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>[</span><span style=color:#fc3>:subexpr</span><span style=color:#555>]</span>
  <span style=color:#069;font-weight:700>end</span>
  <span style=color:#069;font-weight:700>def</span> <span style=color:#c0f>compile_exp</span>(exp)
    <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>if</span> <span style=color:#555>!</span>exp <span style=color:#555>||</span> exp<span style=color:#555>.</span>size <span style=color:#555>==</span> <span style=color:#f60>0</span>
    <span style=color:#069;font-weight:700>return</span> compile_do(<span style=color:#555>*</span>exp<span style=color:#555>[</span><span style=color:#f60>1</span><span style=color:#555>..-</span><span style=color:#f60>1</span><span style=color:#555>]</span>) <span style=color:#069;font-weight:700>if</span> exp<span style=color:#555>[</span><span style=color:#f60>0</span><span style=color:#555>]</span> <span style=color:#555>==</span> <span style=color:#fc3>:do</span>
    <span style=color:#069;font-weight:700>return</span> compile_defun(<span style=color:#555>*</span>exp<span style=color:#555>[</span><span style=color:#f60>1</span><span style=color:#555>..-</span><span style=color:#f60>1</span><span style=color:#555>]</span>) <span style=color:#069;font-weight:700>if</span> exp<span style=color:#555>[</span><span style=color:#f60>0</span><span style=color:#555>]</span> <span style=color:#555>==</span> <span style=color:#fc3>:defun</span>
    <span style=color:#069;font-weight:700>return</span> compile_ifelse(<span style=color:#555>*</span>exp<span style=color:#555>[</span><span style=color:#f60>1</span><span style=color:#555>..-</span><span style=color:#f60>1</span><span style=color:#555>]</span>) <span style=color:#069;font-weight:700>if</span> exp<span style=color:#555>[</span><span style=color:#f60>0</span><span style=color:#555>]</span> <span style=color:#555>==</span> <span style=color:#fc3>:if</span>
    <span style=color:#069;font-weight:700>return</span> compile_lambda(<span style=color:#555>*</span>exp<span style=color:#555>[</span><span style=color:#f60>1</span><span style=color:#555>..-</span><span style=color:#f60>1</span><span style=color:#555>]</span>) <span style=color:#069;font-weight:700>if</span> exp<span style=color:#555>[</span><span style=color:#f60>0</span><span style=color:#555>]</span> <span style=color:#555>==</span> <span style=color:#fc3>:lambda</span>
    <span style=color:#069;font-weight:700>return</span> compile_call(exp<span style=color:#555>[</span><span style=color:#f60>1</span><span style=color:#555>]</span>, exp<span style=color:#555>[</span><span style=color:#f60>2</span><span style=color:#555>]</span>) <span style=color:#069;font-weight:700>if</span> exp<span style=color:#555>[</span><span style=color:#f60>0</span><span style=color:#555>]</span> <span style=color:#555>==</span> <span style=color:#fc3>:call</span>
    <span style=color:#069;font-weight:700>return</span> compile_call(exp<span style=color:#555>[</span><span style=color:#f60>0</span><span style=color:#555>]</span>, <span style=color:#555>*</span>exp<span style=color:#555>[</span><span style=color:#f60>1</span><span style=color:#555>..-</span><span style=color:#f60>1</span><span style=color:#555>]</span>)
  <span style=color:#069;font-weight:700>end</span>
</code></pre></td></tr></table></div></div><p>看起来很不错，不是吗？<code>#compile_call</code> 几乎跟之前的 <code>#compile_exp</code> 一模一样，只不过是把一些代码给提取出来，成为了辅助方法而已。</p><p>那么就来简单地测试一下吧：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>prog <span style=color:#555>=</span> <span style=color:#555>[</span><span style=color:#fc3>:do</span>,
  <span style=color:#555>[</span><span style=color:#fc3>:call</span>, <span style=color:#555>[</span><span style=color:#fc3>:lambda</span>, <span style=color:#555>[]</span>, <span style=color:#555>[</span><span style=color:#fc3>:puts</span>, <span style=color:#c30>&#34;Test&#34;</span><span style=color:#555>]]</span>, <span style=color:#555>[]</span> <span style=color:#555>]</span>
<span style=color:#555>]</span>
</code></pre></td></tr></table></div></div><p>（看起来也没那么糟不是吗？）</p><p>编译运行之：</p><div class=highlight><div style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain>$ ruby step6.rb &gt;step6.s
$ make step6
cc      step6.s  -o step6
$ ./step6
Test
$
</code></pre></td></tr></table></div></div><p>这篇的代码在<a href=http://www.hokstad.com/static/compiler/step6.rb>这里</a>。</p><h2 id=之后的部分>之后的部分</h2><p>因为我合并了几篇文章，下面就列一下更新过后的，“已经写完但还需要整理的”文章列表。因为我肯定还会合并下面的某些部分的，所以我想我需要找时间开始写一些新的部分了（为了完成我所定下的 30 篇的计划）。</p><ul><li>步骤七：再看用匿名函数实现循环，以及对函数参数的访问</li><li>步骤八：实现赋值语句以及简单的四则运算</li><li>步骤九：一个更简洁的 <code>while</code> 循环语句</li><li>步骤十：测试这个语言：实现一个简单的输入转换模块</li><li>步骤十一：重构代码生成器，分离架构相关的部分</li><li>步骤十二：对某些功能点的讨论，以及未来的前进方向</li><li>步骤十三：实现数组</li><li>步骤十四：局部变量以及多重作用域</li><li>步骤十五：访问变长参数列表</li><li>步骤十六：再看输入转换模块，重构以支持新功能，并用其解析它自己</li><li>步骤十七：总结实现自举所需要的功能点</li><li>步骤十八：开始实现真正的解析器</li></ul><h4><i class=fa-share-alt aria-hidden=true></i>&nbsp;Share!</h4><ul class=share-buttons><li><a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.glacjay.info%2fpost%2f2011-05-21%2f%25E7%25BF%25BB%25E8%25AF%2591-%25E7%2594%25A8-ruby-%25E5%2586%2599%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%25E4%25B9%258B%25E5%2585%25AD%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0-lambda%2f"target=_blank title="Share on Facebook"><i class=fa-facebook aria-hidden=true></i><span class=sr-only>Share on Facebook</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="https://twitter.com/intent/tweet?source=https%3a%2f%2fblog.glacjay.info%2fpost%2f2011-05-21%2f%25E7%25BF%25BB%25E8%25AF%2591-%25E7%2594%25A8-ruby-%25E5%2586%2599%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%25E4%25B9%258B%25E5%2585%25AD%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0-lambda%2f&via=HorribleGeek"target=_blank title=Tweet><i class=fa-twitter aria-hidden=true></i><span class=sr-only>Tweet</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="https://plus.google.com/share?url=https%3a%2f%2fblog.glacjay.info%2fpost%2f2011-05-21%2f%25E7%25BF%25BB%25E8%25AF%2591-%25E7%2594%25A8-ruby-%25E5%2586%2599%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%25E4%25B9%258B%25E5%2585%25AD%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0-lambda%2f"target=_blank title="Share on Google+"><i class=fa-google-plus aria-hidden=true></i><span class=sr-only>Share on Google+</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://www.tumblr.com/share?v=3&u=https%3a%2f%2fblog.glacjay.info%2fpost%2f2011-05-21%2f%25E7%25BF%25BB%25E8%25AF%2591-%25E7%2594%25A8-ruby-%25E5%2586%2599%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%25E4%25B9%258B%25E5%2585%25AD%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0-lambda%2f"target=_blank title="Post to Tumblr"><i class=fa-tumblr aria-hidden=true></i><span class=sr-only>Post to Tumblr</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fblog.glacjay.info%2fpost%2f2011-05-21%2f%25E7%25BF%25BB%25E8%25AF%2591-%25E7%2594%25A8-ruby-%25E5%2586%2599%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%25E4%25B9%258B%25E5%2585%25AD%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0-lambda%2f"target=_blank title="Pin it"><i class=fa-pinterest-p aria-hidden=true></i><span class=sr-only>Pin it</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://www.reddit.com/submit?url=https%3a%2f%2fblog.glacjay.info%2fpost%2f2011-05-21%2f%25E7%25BF%25BB%25E8%25AF%2591-%25E7%2594%25A8-ruby-%25E5%2586%2599%25E7%25BC%2596%25E8%25AF%2591%25E5%2599%25A8%25E4%25B9%258B%25E5%2585%25AD%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0-lambda%2f"target=_blank title="Submit to Reddit"><i class=fa-reddit-alien aria-hidden=true></i><span class=sr-only>Submit to Reddit</span></a></li></ul><style>ul.share-buttons{list-style:none;padding:0}ul.share-buttons li{display:inline}ul.share-buttons .sr-only{position:absolute;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}</style><div class="prev-next-post pure-g"><div class=pure-u-1-24 style=text-align:left><a href=https://blog.glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/><i class="fa fa-chevron-left"></i></a></div><div class=pure-u-10-24><nav class=prev><a href=https://blog.glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/>[翻译] 用 Ruby 写编译器之五：整数常量，以及 if 语句</a></nav></div><div class=pure-u-2-24>&nbsp;</div><div class=pure-u-10-24><nav class=next><a href=https://blog.glacjay.info/post/2011-07-26/%E8%BD%AC%E8%BD%BD-compilers-what-are-you-thinking-about/>[转载] Compilers: what are you thinking about?</a></nav></div><div class=pure-u-1-24 style=text-align:right><a href=https://blog.glacjay.info/post/2011-07-26/%E8%BD%AC%E8%BD%BD-compilers-what-are-you-thinking-about/><i class="fa fa-chevron-right"></i></a></div></div><div id=disqus_thread></div><script type=text/javascript>!function(){var a,b;if(window.location.hostname=="localhost")return;a=document.createElement('script'),a.type='text/javascript',a.async=!0,b='glacjay',a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)}()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div><script src=https://blog.glacjay.info/js/ui.js></script><script src=https://blog.glacjay.info/js/menus.js></script><script src=/js/math-code.js></script><script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>