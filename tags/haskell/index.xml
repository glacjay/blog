<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell on Random Stuff from GlacJAY</title>
    <link>https://blog.glacjay.info/tags/haskell/</link>
    <description>Recent content in Haskell on Random Stuff from GlacJAY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 14 Jul 2009 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.glacjay.info/tags/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>在 Haskell 中实现 Generic zip 函数</title>
      <link>https://blog.glacjay.info/post/2009-07-14/%E5%9C%A8-haskell-%E4%B8%AD%E5%AE%9E%E7%8E%B0-generic-zip-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 14 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-07-14/%E5%9C%A8-haskell-%E4%B8%AD%E5%AE%9E%E7%8E%B0-generic-zip-%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;其实嗫，这个问题已经有标准和其他的解决方案了。标准解决方案参见 &lt;code&gt;Control.Applicative&lt;/code&gt; 中的 &lt;code&gt;ZipList&lt;/code&gt; ，不过这东东用起来蛮麻烦的说；其他解决方案见 bff 库的 &lt;code&gt;Data.Zippable&lt;/code&gt; 模块，嗯，我还没搞明白这玩意怎么用，不过总感觉杀鸡用牛刀了有点（Template Haskell ，以及其他依赖）。&lt;/p&gt;

&lt;p&gt;所以，如果你只是跟我一样，看 &lt;code&gt;Data.List&lt;/code&gt; 中的那一砣 &lt;code&gt;zipn&lt;/code&gt; 不顺眼的话（其实也只是看着不顺哈，用着还是蛮顺的，反正实现不用我写），一个更简单的方案在此：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Haskell 中的可变长参数列表</title>
      <link>https://blog.glacjay.info/post/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</link>
      <pubDate>Wed, 06 May 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.glacjay.info/post/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</guid>
      <description>&lt;p&gt;说实话，我之前有就这个题目很有激情地写了很长很罗嗦的一篇草稿的，哦，确切来说是大半篇，直到被打断，激情不再，这篇草稿也就此躺了两个多月。好吧，其实是我还不是八卦那块料，就不卖弄了，直接总结。&lt;/p&gt;

&lt;p&gt;要在 Haskell 中实现可变长参数列表，就是利用其 Typeclass 系统，对函数进行最终结果类型和中间函数类型之间的重载，然后利用 Haskell 的类型推导机制为我们自动调用合适的重载版本。嗯，就这么简单。下面是一个最简单的例子：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>