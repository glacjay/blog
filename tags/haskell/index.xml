<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>haskell on Random Stuff from GlacJAY</title><link>https://blog.glacjay.info/tags/haskell/</link><description>Recent content in haskell on Random Stuff from GlacJAY</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 14 Jul 2009 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.glacjay.info/tags/haskell/index.xml" rel="self" type="application/rss+xml"/><item><title>在 Haskell 中实现 Generic zip 函数</title><link>https://blog.glacjay.info/post/2009-07-14/%E5%9C%A8-haskell-%E4%B8%AD%E5%AE%9E%E7%8E%B0-generic-zip-%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 14 Jul 2009 00:00:00 +0000</pubDate><guid>https://blog.glacjay.info/post/2009-07-14/%E5%9C%A8-haskell-%E4%B8%AD%E5%AE%9E%E7%8E%B0-generic-zip-%E5%87%BD%E6%95%B0/</guid><description>&lt;p>其实嗫，这个问题已经有标准和其他的解决方案了。标准解决方案参见 &lt;code>Control.Applicative&lt;/code> 中的 &lt;code>ZipList&lt;/code> ，不过这东东用起来蛮麻烦的说；其他解决方案见 bff 库的 &lt;code>Data.Zippable&lt;/code> 模块，嗯，我还没搞明白这玩意怎么用，不过总感觉杀鸡用牛刀了有点（Template Haskell ，以及其他依赖）。&lt;/p>
&lt;p>所以，如果你只是跟我一样，看 &lt;code>Data.List&lt;/code> 中的那一砣 &lt;code>zipn&lt;/code> 不顺眼的话（其实也只是看着不顺哈，用着还是蛮顺的，反正实现不用我写），一个更简单的方案在此：&lt;/p></description></item><item><title>Haskell 中的可变长参数列表</title><link>https://blog.glacjay.info/post/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</link><pubDate>Wed, 06 May 2009 00:00:00 +0000</pubDate><guid>https://blog.glacjay.info/post/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</guid><description>&lt;p>说实话，我之前有就这个题目很有激情地写了很长很罗嗦的一篇草稿的，哦，确切来说是大半篇，直到被打断，激情不再，这篇草稿也就此躺了两个多月。好吧，其实是我还不是八卦那块料，就不卖弄了，直接总结。&lt;/p>
&lt;p>要在 Haskell 中实现可变长参数列表，就是利用其 Typeclass 系统，对函数进行最终结果类型和中间函数类型之间的重载，然后利用 Haskell 的类型推导机制为我们自动调用合适的重载版本。嗯，就这么简单。下面是一个最简单的例子：&lt;/p></description></item></channel></rss>