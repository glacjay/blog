<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>erlang on Random Stuff from GlacJAY</title><link>https://blog.glacjay.info/tags/erlang/</link><description>Recent content in erlang on Random Stuff from GlacJAY</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 22 Nov 2010 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.glacjay.info/tags/erlang/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenVPN 的握手协议分析</title><link>https://blog.glacjay.info/post/2010-11-22/openvpn-%E7%9A%84%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</link><pubDate>Mon, 22 Nov 2010 00:00:00 +0000</pubDate><guid>https://blog.glacjay.info/post/2010-11-22/openvpn-%E7%9A%84%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</guid><description>&lt;p>又是好久没来这儿了啊。&lt;/p>
&lt;p>最近因为工作需要（其实也没需要那么多），一直在断断续续地看 OpenVPN 的代码，终于大概搞清楚了它的握手是怎么个流程了。简单来说的话其实非常的简单，首先在 &lt;code>reliable&lt;/code> 模块中实现了一个可靠的 UDP 报文协议，就是加上超时重传和确认报文的功能；然后用该协议交换一个 Hard Reset 命令，开始握手；最后建立 SSL 对象，并且通过内存 &lt;code>BIO&lt;/code> 在可靠 UDP 协议的基础上转发 OpenSSL 的握手协议报文，通过这个 SSL 连接交换 OpenVPN 自己的密钥。接下来就是用这些密钥，该干嘛干嘛了。&lt;/p></description></item></channel></rss>